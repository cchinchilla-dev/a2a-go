// Copyright 2025 The A2A Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package a2asrv

import (
	"context"

	"github.com/a2aproject/a2a-go/a2a"
	"github.com/a2aproject/a2a-go/a2asrv/taskstore"
)

type callContextKeyType struct{}

// CallContextFrom allows to get a CallContext struct which holds additional information
// about the current execution scope.
func CallContextFrom(ctx context.Context) (*CallContext, bool) {
	callCtx, ok := ctx.Value(callContextKeyType{}).(*CallContext)
	return callCtx, ok
}

// NewCallContext can be called by a transport implementations to provide request metadata to [RequestHandler]
// or to have access to the list of activated extensions via the returned CallContext after the call ends.
// If context already had a [CallContext] attached, the old context will be shadowed.
func NewCallContext(ctx context.Context, params *ServiceParams) (context.Context, *CallContext) {
	callCtx := &CallContext{User: &User{Authenticated: false}, svcParams: params}
	return context.WithValue(ctx, callContextKeyType{}, callCtx), callCtx
}

// CallContext holds information about the current server call scope.
type CallContext struct {
	method              string
	svcParams           *ServiceParams
	activatedExtensions []string

	// User can be set by authentication middleware to provide information about
	// the user who initiated the request.
	User *User
}

// Method returns the name of the RequestHandler method which is being executed.
func (cc *CallContext) Method() string {
	return cc.method
}

// ServiceParams returns metadata of the request which created the call context.
func (cc *CallContext) ServiceParams() *ServiceParams {
	return cc.svcParams
}

// Extensions returns a struct which provides an API for working with extensions in the current call context.
func (cc *CallContext) Extensions() *Extensions {
	return &Extensions{callCtx: cc}
}

// Request represents a transport-agnostic request received by the A2A server.
type Request struct {
	// Payload is one of a2a package core types. It is nil when a request does not have any parameters.
	Payload any
}

// Response represents a transport-agnostic response generated by the A2A server.
// Payload is one of a2a package core types.
type Response struct {
	// Payload is one of a2a package core types. It is nil when Err is set or when a request does not return any value.
	Payload any
	// Err is set to indicate that request processing failed.
	Err error
}

// CallInterceptor can be attached to an [RequestHandler]. If multiple interceptors are added:
//   - Before will be executed in the order of attachment sequentially.
//   - After will be executed in the reverse order sequentially.
type CallInterceptor interface {
	// Before allows to observe, modify or reject a Request.
	// A new context.Context can be returned to pass information down the call stack.
	// If either the result (2nd return value) or the error (3rd return value) is non nil,
	// the actual handler will not be called and the value will be returned to the client.
	Before(ctx context.Context, callCtx *CallContext, req *Request) (context.Context, any, error)

	// After allows to observe, modify or reject a Response.
	// Context passed to this method will be the same as returned from [CallInterceptor.Before].
	After(ctx context.Context, callCtx *CallContext, resp *Response) error
}

// NewTaskStoreAuthenticator returns a taskstore.Authenticator which uses the CallContext to get the user name.
func NewTaskStoreAuthenticator() taskstore.Authenticator {
	return func(ctx context.Context) (string, error) {
		if callCtx, ok := CallContextFrom(ctx); ok {
			return callCtx.User.Name, nil
		}
		return "", a2a.ErrUnauthenticated
	}
}

// WithCallInterceptors adds a [CallInterceptor] which will be applied to all requests and responses.
func WithCallInterceptors(interceptors ...CallInterceptor) RequestHandlerOption {
	return func(ih *InterceptedHandler, h *defaultRequestHandler) {
		ih.Interceptors = append(ih.Interceptors, interceptors...)
	}
}

// PassthroughCallInterceptor can be used by [CallInterceptor] implementers who don't need all methods.
// The struct can be embedded for providing a no-op implementation.
type PassthroughCallInterceptor struct{}

// Before implements [CallInterceptor.Before].
func (PassthroughCallInterceptor) Before(ctx context.Context, callCtx *CallContext, req *Request) (context.Context, any, error) {
	return ctx, nil, nil
}

// After implements [CallInterceptor.After].
func (PassthroughCallInterceptor) After(ctx context.Context, callCtx *CallContext, resp *Response) error {
	return nil
}
